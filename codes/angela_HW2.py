# -*- coding: utf-8 -*-
"""Angela Huang - Homework2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wpZ9O4ROOA-NnRYH-TETjww2cJUKuCwQ

#Homework 2
"""

import numpy as np
import scipy as sp
import matplotlib.pyplot as plt
import cmath as cm
import math

import scipy.special as sf

def wavefunctions(k):
  n=0
  resultlist = []
  while n<4:
    for i in k:
      result = (1/(np.power(np.pi,1/4))) * (1/(np.power((np.power(2,n)) * sf.factorial(n),1/2))) * (sf.eval_hermite(n,i)) * (np.exp(-np.power(i,2)/2))
      resultlist.append(result)
    n+=1
  return resultlist

L1=[-3,-2,-1,0,1,2,3]
#print(wavefunctions(L1))

plt.plot(L1,wavefunctions(L1)[0:7],label="n=0")
plt.plot(L1,wavefunctions(L1)[7:14],label="n=1")
plt.plot(L1,wavefunctions(L1)[14:21],label="n=2")
plt.plot(L1,wavefunctions(L1)[21:28],label="n=3")

plt.xlabel("Energy")
plt.ylabel("Wavefunctions")
plt.legend(loc="upper left")

"""## Problem 2

_Using informal arguments_

Write a function `polynomial` which implements a polynomial function of arbitrary integer order $n$:

$$ f(x) = c_0 + c_1 x + c_2 x^2 + \cdots + c_n x^n $$

The function should take $x$ as a formal argument and the constants $\{c_i\}$ as informal arguments. You will have to use the `*args` function argument (see Lecture 6). The `enumerate` builtin function will also be convenient (but not absolutely necessary) in order to get the power $i$ to go along with each $c_i$. Recall, you can index tuples just like arrays by using [].

Test your function by plotting:

$$ f(x) = 1 + 2 x^2 -4 x^3 + x^4$$

over the range (-3,3).
"""

def polynomial(x,*args):
  return sum((a*x**i for i,a in enumerate(*args)))

##test function
L1=[]
for i in range(-3,3):
  L1.append(i)
L2=[1,0,2,-4,1]
L3=[]
for i in L1:
  L3.append(polynomial(i,L2))
plt.plot(L1,L3)

"""## Problem 3

Write a function `biggest_gap(L)` that takes a list L of real numbers or integers and finds the largest difference $|a-b|$ between two adjacent elements $a$ and $b$. The function should return $|a-b|$ and the index of the second of the two elements.

As an example, a correctly written `biggest_gap` should return `25,2` when run on `L=[7, 13, 38, 43, 53]`.

Test your function on the array `A` above and show the result.

"""

def biggest_gap(L):  
  a = L[0]
  b = L[1]
  biggest = abs(a-b)

  for i in L:
    index = 0
    a = L[index+1]
    b = L[index+2]
    diff = abs(a-b)
    if diff>biggest:
      biggest = diff
    else:
      pass
    index=+1
  resultlist = []
  resultlist.append(biggest)
  resultlist.append(index+1)
  return resultlist

#example
L=[7, 13, 38, 43, 53]
print(biggest_gap(L))

"""## Problem 4

Following the procedure we used in class, convert the following table into a `numpy` `ndarray`. Then, use array arithmetic to compute a new array:

$$ X= \frac{V}{I^2 r^2} $$

Here $r$ is the average of the measurements `R` and `L` in the table. Finally, write a function `mean_rms` which takes in an array of real numbers $X=\{x_i\}$ and computes the mean $\bar{x}$ and the RMS (root-mean-square), conventionally denoted as $\sigma$. The RMS is defined as:

$$ \sigma = \frac{1}{\sqrt{N-1}}\sqrt{\sum_{i=0}^{N} (\bar{x} - x_i)^2 }$$

Your function should compute the mean and RMS "from scratch" and return $\bar{x},\sigma$. There are multiple ways of doing this including using array arithmetic and/or `for` loops. You can of course use needed functions like square root, and so on. Is there a function that sums an array, say in `numpy`?
"""

# data   Va(V), I(A), R(cm), L(cm)
raw_data=[(275, 1.30, 4.1, 3.1),
          (275, 1.20, 4.7, 3.7),
          (275, 1.10, 5.3, 4.0),
          (275, 1.40, 3.7, 3.3),
          (275, 1.50, 3.3, 2.9),
          (285, 1.50, 3.5, 2.8),
          (285, 1.40, 3.7, 3.0),
          (285, 1.30, 4.2, 3.4),
          (285, 1.20, 4.6, 3.9),
          (285, 1.10, 4.9, 4.2)]

data = np.array(raw_data)

V=data[:,0]
I=data[:,1]
R=data[:,2]
L=data[:,3]

X=V/(I**2*((R+L)/2)**2)

def mean_rms(X):
  #mean
  mean = np.sum(X)/len(X)
  #rms
  L0=[]
  for i in X:
    L0.append((mean-i)**2)
  inner = np.sum(L0)
  rms = (1/(math.sqrt(len(X)-1))) * math.sqrt(inner)
  return [mean,rms]

#print(mean_rms(X))